True,1,2019-07-15 10:08:58.037+0000,"CREATE TABLE IF NOT EXISTS cluster (  name        text PRIMARY KEY,  partitioner text,  seed_hosts  set<text>);CREATE TABLE IF NOT EXISTS repair_unit (  id              bigint PRIMARY KEY,  cluster_name    text,  keyspace_name   text,  column_families set<text>,  incremental_repair boolean);CREATE TABLE IF NOT EXISTS repair_run (  id                 bigint PRIMARY KEY,  cluster_name       text,  repair_unit_id     bigint,  cause              text,  owner              text,  state              text,  creation_time      timestamp,  start_time         timestamp,  end_time           timestamp,  pause_time         timestamp,  intensity          double                    ,  last_event         text                    ,  segment_count      int                     ,  repair_parallelism text);CREATE TABLE IF NOT EXISTS repair_run_by_cluster(  cluster_name text,  id bigint,  PRIMARY KEY(cluster_name, id));CREATE TABLE IF NOT EXISTS repair_run_by_unit(  repair_unit_id bigint,  id bigint,  PRIMARY KEY(repair_unit_id, id));CREATE TABLE IF NOT EXISTS repair_segment (  id               bigint PRIMARY KEY,  repair_unit_id   bigint,  run_id           bigint,  start_token      varint,  end_token        varint,  state            int   ,  coordinator_host text,  start_time       timestamp,  end_time         timestamp,  fail_count       INT);CREATE TABLE IF NOT EXISTS repair_segment_by_run_id (  run_id           bigint,  segment_id       bigint,  PRIMARY KEY(run_id, segment_id));CREATE TABLE IF NOT EXISTS repair_schedule (  id                 bigint PRIMARY KEY,  repair_unit_id     bigint,  state              text                    ,  days_between       int                ,  next_activation    timestamp,  run_history        set<bigint>,  segment_count      int                     ,  repair_parallelism text                    ,  intensity          double                    ,  creation_time      timestamp,  owner              text                    ,  pause_time         timestamp);CREATE TABLE IF NOT EXISTS repair_schedule_by_cluster_and_keyspace(  cluster_name text,  keyspace_name text,  repair_schedule_id bigint,  PRIMARY KEY((cluster_name, keyspace_name), repair_schedule_id));CREATE TABLE IF NOT EXISTS repair_id(  id_type text PRIMARY KEY,  id bigint);",001_Initialize_db.cql
True,2,2019-07-15 10:09:21.219+0000,ALTER TABLE cluster    WITH compaction = {'class': 'LeveledCompactionStrategy'}    AND caching = {'rows_per_partition': 'ALL'};ALTER TABLE repair_unit    WITH compaction = {'class': 'LeveledCompactionStrategy'}    AND caching = {'rows_per_partition': 10};ALTER TABLE repair_run    WITH compaction = {'class': 'LeveledCompactionStrategy'}    AND caching = {'rows_per_partition': 10};ALTER TABLE repair_run_by_cluster    WITH compaction = {'class': 'LeveledCompactionStrategy'}    AND caching = {'rows_per_partition': 10};ALTER TABLE repair_run_by_unit    WITH compaction = {'class': 'LeveledCompactionStrategy'}    AND caching = {'rows_per_partition': 10};ALTER TABLE repair_segment    WITH compaction = {'class': 'LeveledCompactionStrategy'};ALTER TABLE repair_segment_by_run_id    WITH compaction = {'class': 'LeveledCompactionStrategy'}    AND caching = {'rows_per_partition': 10};ALTER TABLE repair_schedule    WITH compaction = {'class': 'LeveledCompactionStrategy'}    AND caching = {'rows_per_partition': 10};ALTER TABLE repair_schedule_by_cluster_and_keyspace    WITH compaction = {'class': 'LeveledCompactionStrategy'}    AND caching = {'rows_per_partition': 10};ALTER TABLE repair_id    WITH compaction = {'class': 'LeveledCompactionStrategy'}    AND caching = {'rows_per_partition': 10};,002_table_properties.cql
True,3,2019-07-15 10:09:31.001+0000,"ALTER TABLE cluster  WITH compaction = {'class': 'LeveledCompactionStrategy'}  AND caching = {'rows_per_partition': 'ALL'};CREATE TABLE IF NOT EXISTS repair_unit_v1 (  id              timeuuid PRIMARY KEY,  cluster_name    text,  keyspace_name   text,  column_families set<text>,  incremental_repair boolean)  WITH compaction = {'class': 'LeveledCompactionStrategy'}    AND caching = {'rows_per_partition': 1};DROP TABLE IF EXISTS repair_run;CREATE TABLE IF NOT EXISTS repair_run (  id                 timeuuid,  cluster_name       text      STATIC,  repair_unit_id     timeuuid    STATIC,  cause              text      STATIC,  owner              text      STATIC,  state              text      STATIC,  creation_time      timestamp STATIC,  start_time         timestamp STATIC,  end_time           timestamp STATIC,  pause_time         timestamp STATIC,  intensity          double    STATIC,  last_event         text      STATIC,  segment_count      int       STATIC,  repair_parallelism text      STATIC,  segment_id         timeuuid,  start_token        varint,  end_token          varint,  segment_state      int,  coordinator_host   text,  segment_start_time timestamp,  segment_end_time   timestamp,  fail_count         int,  PRIMARY KEY (id, segment_id))  WITH compaction = {'class': 'LeveledCompactionStrategy'}  AND caching = {'rows_per_partition': 5000};DROP TABLE IF EXISTS repair_run_by_cluster;CREATE TABLE IF NOT EXISTS repair_run_by_cluster (  cluster_name text,  id           timeuuid,  PRIMARY KEY(cluster_name, id))  WITH compaction = {'class': 'LeveledCompactionStrategy'}  AND caching = {'rows_per_partition': 'ALL'};DROP TABLE IF EXISTS repair_run_by_unit;CREATE TABLE IF NOT EXISTS repair_run_by_unit (  repair_unit_id timeuuid,  id             timeuuid,  PRIMARY KEY(repair_unit_id, id))  WITH compaction = {'class': 'LeveledCompactionStrategy'}  AND caching = {'rows_per_partition': 'ALL'};CREATE TABLE IF NOT EXISTS repair_schedule_v1 (  id                 timeuuid PRIMARY KEY,  repair_unit_id     timeuuid,  state              text                    ,  days_between       int                ,  next_activation    timestamp,  run_history        set<timeuuid>,  segment_count      int                     ,  repair_parallelism text                    ,  intensity          double                    ,  creation_time      timestamp,  owner              text                    ,  pause_time         timestamp)  WITH compaction = {'class': 'LeveledCompactionStrategy'}  AND caching = {'rows_per_partition': 1};DROP TABLE IF EXISTS repair_schedule_by_cluster_and_keyspace;CREATE TABLE IF NOT EXISTS repair_schedule_by_cluster_and_keyspace (  cluster_name text,  keyspace_name text,  repair_schedule_id timeuuid,  PRIMARY KEY((cluster_name, keyspace_name), repair_schedule_id))  WITH compaction = {'class': 'LeveledCompactionStrategy'}  AND caching = {'rows_per_partition': 10};DROP TABLE IF EXISTS repair_segment;DROP TABLE IF EXISTS repair_segment_by_run_id;DROP TABLE IF EXISTS repair_id;",003_switch_to_uuids.cql
True,4,2019-07-15 10:09:42.449+0000,"CREATE TABLE IF NOT EXISTS leader (\tleader_id timeuuid PRIMARY KEY,\treaper_instance_id uuid,\treaper_instance_host text,\tlast_heartbeat timestamp) WITH compaction = {'class': 'LeveledCompactionStrategy'}    AND default_time_to_live = 600    AND gc_grace_seconds = 600;CREATE TABLE IF NOT EXISTS running_reapers (    reaper_instance_id uuid PRIMARY KEY,    reaper_instance_host text,    last_heartbeat timestamp) WITH compaction = {'class': 'LeveledCompactionStrategy'}    AND default_time_to_live = 180    AND gc_grace_seconds = 180;CREATE TABLE IF NOT EXISTS node_metrics (    host_address text,    datacenter text,    pending_compactions int,    has_repair_running boolean,    active_anticompactions int,    PRIMARY KEY (host_address) ) WITH compaction = {'class': 'LeveledCompactionStrategy'}    AND default_time_to_live = 180    AND gc_grace_seconds = 180;",004_fault_tolerant_reaper.cql
True,5,2019-07-15 10:09:53.000+0000,ALTER TABLE repair_unit_v1 ADD nodes set<text>;ALTER TABLE repair_unit_v1 ADD \"datacenters\" set<text>;,005_repair_specific_nodes.cql
True,6,2019-07-15 11:16:32.000+0000,ALTER TABLE repair_unit_v1 ADD blacklisted_tables set<text>;,006_table_blacklist.cql
True,7,2019-07-15 11:33:27.232+0000,ALTER TABLE repair_schedule_v1 ADD segment_count_per_node int;,007_segment_count_per_node.cql
True,8,2019-07-15 11:33:29.465+0000,"DROP TABLE IF EXISTS node_metrics;CREATE TABLE IF NOT EXISTS node_metrics_v1 (  time_partition          bigint,  run_id                  uuid,  node                    text,  cluster                 text,  datacenter              text,  requested               boolean,  pending_compactions     int,  has_repair_running      boolean,  active_anticompactions  int,  PRIMARY KEY((run_id, time_partition), node))  WITH compaction = {'class':'SizeTieredCompactionStrategy', 'unchecked_tombstone_compaction':'true'}   AND caching = {'keys':'ALL', 'rows_per_partition':'ALL'}   AND  gc_grace_seconds = 120   AND  default_time_to_live = 180;",008_request_for_metrics.cql
True,9,2019-07-15 11:33:29.896+0000,,009_remove_nulls.cql
True,10,2019-07-15 11:33:34.168+0000,"ALTER TABLE repair_unit_v1  WITH caching = {'keys':'ALL', 'rows_per_partition':'1'};ALTER TABLE repair_schedule_by_cluster_and_keyspace  WITH caching = {'keys':'ALL', 'rows_per_partition':'10'};ALTER TABLE repair_run_by_cluster  WITH caching = {'keys':'ALL', 'rows_per_partition':'ALL'};ALTER TABLE repair_schedule_v1  WITH caching = {'keys':'ALL', 'rows_per_partition':'1'};ALTER TABLE cluster  WITH caching = {'keys':'ALL', 'rows_per_partition':'ALL'};ALTER TABLE repair_run  WITH caching = {'keys':'ALL', 'rows_per_partition':'5000'};ALTER TABLE repair_run_by_unit  WITH caching = {'keys':'ALL', 'rows_per_partition':'ALL'};",010_table_properties.cql
True,11,2019-07-15 11:33:34.350+0000,,011_fix_start_times.cql
True,12,2019-07-15 11:33:34.552+0000,,012_fix_start_times.cql
True,13,2019-07-15 11:33:35.188+0000,"CREATE TABLE IF NOT EXISTS snapshot (  cluster                 text,  snapshot_name           text,  owner                   text,  cause                   text,  creation_time           timestamp,  PRIMARY KEY((cluster, snapshot_name)))WITH compaction = {'class':'LeveledCompactionStrategy'}   AND caching = {'keys':'ALL', 'rows_per_partition':'ALL'}   AND  gc_grace_seconds = 864000   AND  default_time_to_live = 0;",013_snapshots.cql
True,14,2019-07-15 11:33:36.148+0000,ALTER TABLE repair_run ADD token_ranges text;,014_segment_coalescing.cql
True,15,2019-07-15 11:33:37.098+0000,ALTER TABLE repair_unit_v1 ADD repair_thread_count int;,015_multithreaded_repair.cql
True,16,2019-07-15 11:33:37.280+0000,,016_disable_dclocal_read_repair_chance.cql
True,17,2019-07-15 11:33:38.194+0000,ALTER TABLE cluster ADD properties text;,017_add_custom_jmx_port.cql
True,18,2019-07-15 11:33:38.362+0000,,018_fix_repair_run_timestamps.cql
True,19,2019-07-15 11:33:38.801+0000,,019_fix_repair_run_timestamps.cql
